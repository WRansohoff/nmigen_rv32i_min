# Minimal `RISC-V` CPU

This is a work-in-progress implementation of [the core `RV32I` `RISC-V` instruction set](https://riscv.org/specifications/isa-spec-pdf/), written with nMigen.

Currently it only runs in the simulator, but I'm planning to add a module to read program data from SPI Flash and get it running on an iCE40 FPGA once the implementation is more complete.

Know that I'm still learning how to use nMigen, and I wasn't experienced with digital logic design to begin with. So on the off chance that anybody stumbles across this, suggestions are always welcome!

# Prerequisites

This project uses [nMigen](https://github.com/nmigen/nmigen), which is a super cool Python 3.x library that lets you describe digital logic circuits. So you'll need to install a recent version of Python, and then you can either build nMigen from source or install it with Pip:

    pip3 install nmigen

# Testbenches

The ALU, CSR, RAM, and ROM Python files each have their own testbench to run some basic unit tests.

The CPU module's testbench runs the standard `rv32ui` [`RISC-V` instruction set tests](https://github.com/riscv/riscv-tests) for each operation, compiled with GCC.

Out of the core `RV32UI` operation tests, only the `FENCE` tests fail. I believe that the failure is due to an expectation that the `riscv-tests` be run from re-writable memory (not a simulated ROM), and I've applied a patch which addresses that. But I don't want to say that the `FENCE` tests pass until (if) that patch gets accepted upstream.

I also included the `RV32SI` `CSR` tests, which are also failing at the moment. But I am hoping to implement the minimal 'machine mode' registers.

I also haven't implemented system calls or traps yet, and I had to comment out some of the startup code in `riscv_test.h`, or the simulation wouldn't even make it to the start of the tests. So there's still plenty of work to do.

The `tests/rv64ui_tests/` directory contains assembly code for those test cases, copied [from the `isa/` directory of the `riscv-tests` repository](https://github.com/riscv/riscv-tests/tree/master/isa). And the `tests/test_roms/` directory contains auto-generated Python files with corresponding machine code instructions in a format that the CPU testbenches can interpret.

The nMigen-compatible tests are generated by the `tests/gen_tests.py` script, which you'll need to run before you run the CPU testbenches:

    python3 tests/gen_tests.py

To run a module's testbench, just run the corresponding `.py` file:

    python3 cpu.py

Each test simulation also creates a `.vcd` file containing the waveform results, so you can check how each signal changes over time.

# Test Coverage

Note: `EBREAK` instructions are halt or crash the program, depending on your perspective.

`ECALL` instructions are also very incomplete, so these tests only work when the usual startup code is skipped over. And that startup code includes the logic which loads initial RAM values, which means that the 'load' and 'store' tests need to manually set starting RAM values from the `.data` section to pass.

So even though this table of test coverage doesn't look too bad, there's plenty more work to do before the design will actually work with real-world programs.

| Instruction |   Pass / Fail?   |
|:-----------:|:----------------:|
| `ADD`       |:heavy_check_mark:|
| `ADDI`      |:heavy_check_mark:|
| `AND`       |:heavy_check_mark:|
| `ANDI`      |:heavy_check_mark:|
| `AUIPC`     |:heavy_check_mark:|
| `BEQ`       |:heavy_check_mark:|
| `BGE`       |:heavy_check_mark:|
| `BGEU`      |:heavy_check_mark:|
| `BLT`       |:heavy_check_mark:|
| `BLTU`      |:heavy_check_mark:|
| `BNE`       |:heavy_check_mark:|
| `CSR`       |       :x:        |
| `FENCE`     |       :x:        |
| `JAL`       |:heavy_check_mark:|
| `JALR`      |:heavy_check_mark:|
| `LB`        |:heavy_check_mark:|
| `LBU`       |:heavy_check_mark:|
| `LH`        |:heavy_check_mark:|
| `LHU`       |:heavy_check_mark:|
| `LW`        |:heavy_check_mark:|
| `LUI`       |:heavy_check_mark:|
| `OR`        |:heavy_check_mark:|
| `ORI`       |:heavy_check_mark:|
| `SB`        |:heavy_check_mark:|
| `SH`        |:heavy_check_mark:|
| `SW`        |:heavy_check_mark:|
| `SLL`       |:heavy_check_mark:|
| `SLLI`      |:heavy_check_mark:|
| `SLT`       |:heavy_check_mark:|
| `SLTI`      |:heavy_check_mark:|
| `SLTU`      |:heavy_check_mark:|
| `SLTUI`     |:heavy_check_mark:|
| `SRL`       |:heavy_check_mark:|
| `SRLI`      |:heavy_check_mark:|
| `SRA`       |:heavy_check_mark:|
| `SRAI`      |:heavy_check_mark:|
| `SUB`       |:heavy_check_mark:|
| `XOR`       |:heavy_check_mark:|
| `XORI`      |:heavy_check_mark:|

# Notes to Self

- The RISC-V spec says that any instruction ending in `0x0000` is illegal; I should build that into the CPU, but I haven't yet.

- I haven't implemented traps (interrupts / exceptions) yet.

- `ECALL` and `EBREAK` System calls aren't quite working yet.

- The spec does not define behavior when an unspecified opcode is encountered. For now, I'll just skip to incrementing the PC if that happens. But once I implement traps, it might merit raising an exception.
